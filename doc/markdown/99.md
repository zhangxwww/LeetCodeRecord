# Recover Binary Search Tree

Difficulty: Hard

---

对于一个二叉搜索树，如果写出其中序遍历的结果`a[0], a[1], ...a[n-1]`，一定有`a[i]<a[i+1]`。

而如果交换某两个结点，例如`a[j], a[k]`，得到新的中序遍历：`...a[j-1], a[k], a[j+1], ...a[k-1], a[j], a[k+1]...`，其中`a[k]>a[j+1]`，`a[k-1]>a[j]`。

因此这道题基本思路是，中序遍历二叉树，找到满足前一个结点值大于后一个结点值的两对结点，就对应着需要恢复的结点。

普通的中序遍历需要$O(n)$的空间复杂度，这里可以用Morris算法。该算法可以用$O(1)$的空间中序遍历二叉树。

在通常的中序遍历算法中，需要将当前结点压栈，然后去访问其左子树。而在Morris算法中，通过利用叶子结点的空指针，可以在访问完左子树后，通过新加入的指针重新找到根节点。这样就避免了压栈所带来的空间消耗。

具体来说，对于某个根节点，Morris算法会将该结点的左子树的最右叶结点的右孩子指向根节点。由于中序遍历时，左子树的最右叶结点是左子树中最后一个访问的结点，访问完该结点后，即可通过指针找到根节点。

当某个结点左子树为空，或是其左子树的最右叶结点的右孩子指向自身，说明此时左子树已经全部访问完，应该访问当前结点。访问后，继续对该结点的右孩子做相同的操作。

在本题中，还需要用另一个指针，指向当前访问的上一个结点，用来与当前访问的结点比较大小。这样就能找到上面说到的，满足“前一个结点值大于后一个结点值”的两对结点。